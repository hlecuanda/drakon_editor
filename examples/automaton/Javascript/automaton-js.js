"use strict";



function AutoDemo(undefined) {

var TT_NUMBER = "number"
var TT_OPERATOR = "operator"
var TT_IDENTIFIER = "identifier"

var Lex = {
	initialized: false
}


// Autogenerated with DRAKON Editor 1.32


function BabyFrog_Hungry_food(self, msg) {
    var message
    message = "yam-yam"
    self.state = "Sleepy";
    return message
}

function BabyFrog_Hungry_sleep(self, msg) {
    self.state = "Hungry";
    return "I am hungry"
}

function BabyFrog_Sleepy_food(self, msg) {
    self.state = "Sleepy";
    return "na..."
}

function BabyFrog_Sleepy_sleep(self, msg) {
    self.state = "Hungry";
    return "z-z-z..."
}

function Lexer_identifier_digit(self, data, c) {
    add_char(data, c)
    self.state = "identifier";
}

function Lexer_identifier_letter(self, data, c) {
    add_char(data, c)
    self.state = "identifier";
}

function Lexer_identifier_operator(self, data, c) {
    create_identifier(data)
    add_char(data, c)
    self.state = "operator";
}

function Lexer_identifier_whitespace(self, data, c) {
    create_identifier(data)
    self.state = "idle";
}

function Lexer_idle_digit(self, data, c) {
    add_char(data, c)
    self.state = "number";
}

function Lexer_idle_letter(self, data, c) {
    add_char(data, c)
    self.state = "identifier";
}

function Lexer_idle_operator(self, data, c) {
    add_char(data, c)
    self.state = "operator";
}

function Lexer_idle_whitespace(self, data, c) {
    self.state = "idle";
}

function Lexer_number_digit(self, data, c) {
    add_char(data, c)
    self.state = "number";
}

function Lexer_number_dummy(self, data, c) {
    self.state = "operator";
}

function Lexer_number_letter(self, data, c) {
    add_char(data, c)
    self.state = "number";
}

function Lexer_number_operator(self, data, c) {
    create_number(data)
    add_char(data, c)
    self.state = "operator";
}

function Lexer_number_whitespace(self, data, c) {
    create_number(data)
    self.state = "idle";
}

function Lexer_operator_digit(self, data, c) {
    create_operator(data)
    add_char(data, c)
    self.state = "number";
}

function Lexer_operator_letter(self, data, c) {
    create_operator(data)
    add_char(data, c)
    self.state = "identifier";
}

function Lexer_operator_operator(self, data, c) {
    if (try_make_long_op(data, c)) {
        self.state = "idle";
    } else {
        create_operator(data)
        add_char(data, c)
        self.state = "operator";
    }
}

function Lexer_operator_whitespace(self, data, c) {
    create_operator(data)
    self.state = "idle";
}

function add_char(data, c) {
    data.current.push(c)
}

function array_to_string(chars) {
    var result
    result = ""
    var _ind364 = 0;
    var _col364 = chars;
    var _len364 = _col364.length;
    while (true) {
        if (_ind364 < _len364) {
            
        } else {
            break;
        }
        var char = _col364[_ind364];
        result = result + String.fromCharCode(char)
        _ind364++;
    }
    return result
}

function create_identifier(data) {
    create_token(data, TT_IDENTIFIER)
}

function create_number(data) {
    create_token(data, TT_NUMBER)
}

function create_operator(data) {
    create_token(data, TT_OPERATOR)
}

function create_token(data, type) {
    var text, token
    if (data.current.length === 0) {
        
    } else {
        text = data.current
        data.current = []
        token = token_create(type, text)
        data.tokens.push(token)
    }
}

function first_char(text) {
    return text.charCodeAt(0)
}

function is_digit(c) {
    if ((c >= Lex.ZERO) && (c <= Lex.NINE)) {
        return true
    } else {
        return false
    }
}

function is_letter(c) {
    if (((c >= Lex.A) && (c <= Lex.Z)) || ((c >= Lex.CA) && (c <= Lex.CZ))) {
        return true
    } else {
        return false
    }
}

function is_long_op(first, second) {
    var _ind352 = 0;
    var _col352 = Lex.LONG_OPS;
    var _len352 = _col352.length;
    while (true) {
        if (_ind352 < _len352) {
            
        } else {
            return false
        }
        var long_op = _col352[_ind352];
        if ((long_op.charCodeAt(0) === first) && (long_op.charCodeAt(1) === second)) {
            return true
        }
        _ind352++;
    }
}

function is_operator(c) {
    if (Lex.OP_CHARS[c]) {
        return true
    } else {
        return false
    }
}

function lex_init() {
    var i
    if (Lex.initialized) {
        
    } else {
        Lex.OP_CHARS = []
        Lex.LONG_OPS = ["==", "!=", "<=", ">=" ]
        Lex.initialized = true
        i = 0;
        while (true) {
            if (i < 256) {
                
            } else {
                break;
            }
            Lex.OP_CHARS[i] = false
            i++;
        }
        Lex.OP_CHARS[first_char("!")] = true
        Lex.OP_CHARS[first_char("=")] = true
        Lex.OP_CHARS[first_char("<")] = true
        Lex.OP_CHARS[first_char(">")] = true
        Lex.OP_CHARS[first_char("-")] = true
        Lex.OP_CHARS[first_char("+")] = true
        Lex.OP_CHARS[first_char("/")] = true
        Lex.OP_CHARS[first_char("\\")] = true
        Lex.OP_CHARS[first_char("*")] = true
        Lex.OP_CHARS[first_char("%")] = true
        Lex.OP_CHARS[first_char("(")] = true
        Lex.OP_CHARS[first_char(")")] = true
        Lex.OP_CHARS[first_char("(")] = true
        Lex.OP_CHARS[first_char(")")] = true
        Lex.OP_CHARS[first_char("{")] = true
        Lex.OP_CHARS[first_char("}")] = true
        Lex.OP_CHARS[first_char(":")] = true
        Lex.OP_CHARS[first_char(".")] = true
        Lex.OP_CHARS[first_char("#")] = true
        Lex.OP_CHARS[first_char(",")] = true
        Lex.OP_CHARS[first_char("^")] = true
        Lex.OP_CHARS[first_char("|")] = true
        Lex.OP_CHARS[first_char("&")] = true
        Lex.OP_CHARS[first_char("'")] = true
        Lex.OP_CHARS[first_char("\"")] = true
        Lex.ZERO = first_char("0")
        Lex.NINE = first_char("9")
        Lex.A = first_char("a")
        Lex.Z = first_char("z")
        Lex.CA = first_char("A")
        Lex.CZ = first_char("Z")
        Lex.UNDER = first_char("_")
        Lex.SPACE = first_char(" ")
    }
}

function main() {
    var frog, text, tokens
    lex_init()
    text = "foo.Bar(34 / 4-(18+m * 3)) ==800"
    tokens = tokenize(text)
    printHeader("Text to parse")
    printLine(text)
    printHeader("Tokens")
    addHTML("<table id='table1'></table>")
    addTableLine("table1", "th", "Token type", "Token text")
    var _ind357 = 0;
    var _col357 = tokens;
    var _len357 = _col357.length;
    while (true) {
        if (_ind357 < _len357) {
            
        } else {
            break;
        }
        var token = _col357[_ind357];
        token_print(token)
        _ind357++;
    }
    frog = new BabyFrog()
    printLine("The baby frog says:")
    printLine(frog.state + "/sleep")
    printLine(frog.sleep())
    printLine(frog.state + "/food")
    printLine(frog.food())
    printLine(frog.state + "/food")
    printLine(frog.food())
    printLine(frog.state + "/sleep")
    printLine(frog.sleep())
}

function token_create(type, chars) {
    var token
    token = {
        type : type,
        text : array_to_string(chars)
    }
    return token
}

function token_print(token) {
    addTableLine(
        "table1",
        "td",
        token.type,
        token.text
    )
}

function tokenize(text) {
    var c, data, i, lexer
    data = {
        current : [],
        tokens : []
    }
    lexer = new Lexer()
    i = 0;
    while (true) {
        if (i < text.length) {
            
        } else {
            break;
        }
        c = text.charCodeAt(i)
        if ((c === Lex.UNDER) || (is_letter(c))) {
            lexer.letter(data, c)
        } else {
            if (is_digit(c)) {
                lexer.digit(data, c)
            } else {
                if (is_operator(c)) {
                    lexer.operator(data, c)
                } else {
                    lexer.whitespace(data, Lex.SPACE)
                }
            }
        }
        i++;
    }
    lexer.whitespace(data, Lex.SPACE)
    return data.tokens
}

function try_make_long_op(data, c) {
    var previous, text, token
    previous = data.current[0]
    if (is_long_op(previous, c)) {
        data.current = []
        text = [ previous, c ]
        token = token_create(TT_OPERATOR, text)
        data.tokens.push(token)
        return true
    } else {
        return false
    }
}

function Lexer() {
  var _self = this;
  _self.type_name = "Lexer";
  _self.state = "idle";
  _self.digit = function(data, c) {
    var _state_ = _self.state;
    if (_state_ == "idle") {
      return Lexer_idle_digit(_self, data, c);
    }
    else if (_state_ == "identifier") {
      return Lexer_identifier_digit(_self, data, c);
    }
    else if (_state_ == "number") {
      return Lexer_number_digit(_self, data, c);
    }
    else if (_state_ == "operator") {
      return Lexer_operator_digit(_self, data, c);
    }
    return null;
  };
  _self.dummy = function(data, c) {
    var _state_ = _self.state;
    if (_state_ == "number") {
      return Lexer_number_dummy(_self, data, c);
    }
    return null;
  };
  _self.letter = function(data, c) {
    var _state_ = _self.state;
    if (_state_ == "idle") {
      return Lexer_idle_letter(_self, data, c);
    }
    else if (_state_ == "identifier") {
      return Lexer_identifier_letter(_self, data, c);
    }
    else if (_state_ == "number") {
      return Lexer_number_letter(_self, data, c);
    }
    else if (_state_ == "operator") {
      return Lexer_operator_letter(_self, data, c);
    }
    return null;
  };
  _self.operator = function(data, c) {
    var _state_ = _self.state;
    if (_state_ == "idle") {
      return Lexer_idle_operator(_self, data, c);
    }
    else if (_state_ == "identifier") {
      return Lexer_identifier_operator(_self, data, c);
    }
    else if (_state_ == "number") {
      return Lexer_number_operator(_self, data, c);
    }
    else if (_state_ == "operator") {
      return Lexer_operator_operator(_self, data, c);
    }
    return null;
  };
  _self.whitespace = function(data, c) {
    var _state_ = _self.state;
    if (_state_ == "idle") {
      return Lexer_idle_whitespace(_self, data, c);
    }
    else if (_state_ == "identifier") {
      return Lexer_identifier_whitespace(_self, data, c);
    }
    else if (_state_ == "number") {
      return Lexer_number_whitespace(_self, data, c);
    }
    else if (_state_ == "operator") {
      return Lexer_operator_whitespace(_self, data, c);
    }
    return null;
  };
}

function BabyFrog() {
  var _self = this;
  _self.type_name = "BabyFrog";
  _self.state = "Hungry";
  _self.food = function(msg) {
    var _state_ = _self.state;
    if (_state_ == "Hungry") {
      return BabyFrog_Hungry_food(_self, msg);
    }
    else if (_state_ == "Sleepy") {
      return BabyFrog_Sleepy_food(_self, msg);
    }
    return null;
  };
  _self.sleep = function(msg) {
    var _state_ = _self.state;
    if (_state_ == "Hungry") {
      return BabyFrog_Hungry_sleep(_self, msg);
    }
    else if (_state_ == "Sleepy") {
      return BabyFrog_Sleepy_sleep(_self, msg);
    }
    return null;
  };
}


this.main = main

}

new AutoDemo().main()
